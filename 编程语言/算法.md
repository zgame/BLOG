# 时间复杂度

	二分法  logN
	循环		N
	分治 归并  NlogN
	双层循环	 N*N
	
# 交换位置

	 arr[a] = arr[a]+arr[b];
     arr[b] = arr[a]-arr[b];
     arr[a] = arr[a]-arr[b];


# 二分查找法, 可以使用循环， 也可以使用递归  

	数组必须是有序数组， 时间复杂度为：log2(n)
	private static void binarySearch(){
        System.out.println("二分查找法");
        final int find = 10;
        int [] aaa = {0,1,2,3,4,5,6,7,8,9,10};
        int low = 0;
        int high = aaa.length-1 ;
        int now = (high-low)/2;

		if (find > aaa[high] || find < aaa[low]){
            System.out.println("超过界限了，找不到的！");
            return;
        }

        while (low<=high){
            now = (high-low)/2 + low ;
            if (find < aaa[now]){
                high = now -1;
                System.out.println("now "+ now);
                System.out.println("high "+ high);
            }else if(find > aaa[now]){
                low = now + 1;
                System.out.println("now "+ now);
                System.out.println("low "+ low);
            }else if(find == aaa[now]){
                System.out.println("find:  "+ find + " in position: " + now);
                return;
            }
        }
    }

# 选择排序

	进行2次for遍历， N*N/2 ， 第一次找最小的， 第二次找第二小的。。。 遍历次数多，每次都要遍历完整
	int[] aaa = { 20, 15, 0, 1, 2, 3, 4, 5, 6, 7};
 	for(int i=0;i<aaa.length;i++){
            int min = aaa[i];
            int index = i;
            for(int j=i+1;j<aaa.length;j++){
                if (aaa[j]< min){
                    min = aaa[j];
                    index = j;
                }
            }
            if(index!=i){
                //交换
                int temp = aaa[i];
                aaa[i] = aaa[index];
                aaa[index] = temp;
            }
        }

# 插入排序

	进行2次for循环遍历， 最坏的情况是N*N/2， 最好的情况是N-1，  
	依次把右边的数跟左边的数进行比较， 如果小于左边的数，那么就插入到左边数的位置上，  因为插入之后就进行下一个数字遍历了，所以次数要少一些。
	Vector<Integer> re = new Vector<>();
	for (int anAaa : aaa) {
            re.add(anAaa);
        }
	for(int i=1;i<re.size();i++){
            int min = re.get(i);
            for(int j=0;j<i;j++){
                if (min < re.get(j)){
                    //插入
                    re.remove(i);
                    re.add(j,min);
                    AllNum++;
                    break;
                }
            }
        }

# 希尔排序

	先将数据分组，每组进行插入排序之后，整体数组就大致是有序的了，最后再进行插入排序就很快
	https://www.cnblogs.com/chengxiao/p/6104371.html

 	//增量gap，并逐步缩小增量
        for(int gap=arr.length/3;gap>0;gap/=3){				//每间隔3个位置的元素形成一个新组，一起做排序判断
            //从第gap个元素，逐个对其所在组进行直接插入排序操作
            for(int i=gap;i<arr.length;i++){			//  从3开始到最后
                int j = i;
                int temp = arr[j];						//  当前的元素
                if(arr[j]<arr[j-gap]){					//  当前元素跟一个步长的前面元素进行比较
                    while(j-gap>=0 && temp<arr[j-gap]){	//  根据步长一直循环到最前面
                        //移动法
                        arr[j] = arr[j-gap];			// 当前元素位置变成一个步长的前面的大元素了
                        j-=gap;							// 下一个步长，如果前面有大的就一直往后挪
                    }
                    arr[j] = temp;						// 直到已经最小了，或者到头了，那么放下当前元素	
                }
            }
        }

# 归并排序

	public static void sort(Comparable[] a){
        aux = new Comparable[a.length];
        sort(a,0,a.length-1);
    }
    private static void sort(Comparable[]a, int lo, int hi){
        // 将数组a[lo..hi]排序
        if(hi<=lo) return;
        int mid = lo + (hi - lo)/2;
        sort(a,lo,mid); //左半边排序
        sort(a,mid+1,hi); //右半边排序
        merge(a,lo,mid,hi);   //归并结果
        System.out.println("lo:"+lo+"mid:"+mid+"hi:"+hi);
    }
    public static void merge(Comparable[]a, int lo, int mid,int hi){
        //将a[lo..mid] 和a[mid+1..hi] 归并
        int i = lo, j= mid+1;

        // 将a[lo..hi]复制到aux[lo..hi] ，需要额外的一个存储空间
        for(int k = lo;k<= hi;k++){
            aux[k] = a[k];
        }

        // 开始归并到a[lo..hi]
        for(int k=lo;k<=hi;k++){
            if(i>mid){      // 左边到头了, 用右边的元素继续
                a[k] = aux[j++];
            }else if(j > hi){       // 右边到头了 ，用左边的元素继续
                a[k] = aux[i++];
            }else if(less(aux[j] ,aux[i])){   // 右边的元素比较小，用右边的
                a[k] = aux[j++];
            }else {
                a[k] = aux[i++];            // 不用做啥
            }
        }
    }

	// merge的输出， 各个分段排序，再各个分段不停的合并
	lo:0   mid:0   hi:1
	lo:0   mid:1   hi:2
	lo:3   mid:3   hi:4
	lo:0   mid:2   hi:4
	lo:5   mid:5   hi:6
	lo:7   mid:7   hi:8
	lo:5   mid:6   hi:8
	lo:0   mid:4   hi:8




# 快速排序

	
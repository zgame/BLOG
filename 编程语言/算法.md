	https://www.cnblogs.com/wangyingli/category/889107.html

# 时间复杂度

	二分法  logN
	循环		N
	分治 归并  NlogN
	双层循环	 N*N
	
# 交换位置

	 arr[a] = arr[a]+arr[b];
     arr[b] = arr[a]-arr[b];
     arr[a] = arr[a]-arr[b];


# 二分查找法, 可以使用循环， 也可以使用递归  

	数组必须是有序数组， 时间复杂度为：log2(n)
	private static void binarySearch(){
        System.out.println("二分查找法");
        final int find = 10;
        int [] aaa = {0,1,2,3,4,5,6,7,8,9,10};
        int low = 0;
        int high = aaa.length-1 ;
        int now = (high-low)/2;

		if (find > aaa[high] || find < aaa[low]){
            System.out.println("超过界限了，找不到的！");
            return;
        }

        while (low<=high){
            now = (high-low)/2 + low ;
            if (find < aaa[now]){
                high = now -1;
                System.out.println("now "+ now);
                System.out.println("high "+ high);
            }else if(find > aaa[now]){
                low = now + 1;
                System.out.println("now "+ now);
                System.out.println("low "+ low);
            }else if(find == aaa[now]){
                System.out.println("find:  "+ find + " in position: " + now);
                return;
            }
        }
    }


# 冒泡排序
	
	排序思想：依次比较相邻的两个元素，若它们的顺序错误则交换，每次循环都将最大（或最小）元素放在序列一端。

# 选择排序

	进行2次for遍历， N*N/2 ， 第一次找最小的， 第二次找第二小的。。。 遍历次数多，每次都要遍历完整
	int[] aaa = { 20, 15, 0, 1, 2, 3, 4, 5, 6, 7};
 	for(int i=0;i<aaa.length;i++){
            int min = aaa[i];
            int index = i;
            for(int j=i+1;j<aaa.length;j++){
                if (aaa[j]< min){
                    min = aaa[j];
                    index = j;
                }
            }
            if(index!=i){
                //交换
                int temp = aaa[i];
                aaa[i] = aaa[index];
                aaa[index] = temp;
            }
        }

# 插入排序

	进行2次for循环遍历， 最坏的情况是N*N/2， 最好的情况是N-1，  
	依次把右边的数跟左边的数进行比较， 如果小于左边的数，那么就插入到左边数的位置上，  因为插入之后就进行下一个数字遍历了，所以次数要少一些。
	Vector<Integer> re = new Vector<>();
	for (int anAaa : aaa) {
            re.add(anAaa);
        }
	for(int i=1;i<re.size();i++){
            int min = re.get(i);
            for(int j=0;j<i;j++){
                if (min < re.get(j)){
                    //插入
                    re.remove(i);
                    re.add(j,min);
                    AllNum++;
                    break;
                }
            }
        }

# 希尔排序

	先将数据分组，每组进行插入排序之后，整体数组就大致是有序的了，最后再进行插入排序就很快
	https://www.cnblogs.com/chengxiao/p/6104371.html

 	//增量gap，并逐步缩小增量
        for(int gap=arr.length/3;gap>0;gap/=3){				//每间隔3个位置的元素形成一个新组，一起做排序判断
            //从第gap个元素，逐个对其所在组进行直接插入排序操作
            for(int i=gap;i<arr.length;i++){			//  从3开始到最后
                int j = i;
                int temp = arr[j];						//  当前的元素
                if(arr[j]<arr[j-gap]){					//  当前元素跟一个步长的前面元素进行比较
                    while(j-gap>=0 && temp<arr[j-gap]){	//  根据步长一直循环到最前面
                        //移动法
                        arr[j] = arr[j-gap];			// 当前元素位置变成一个步长的前面的大元素了
                        j-=gap;							// 下一个步长，如果前面有大的就一直往后挪
                    }
                    arr[j] = temp;						// 直到已经最小了，或者到头了，那么放下当前元素	
                }
            }
        }

# 归并排序

	public static void sort(Comparable[] a){
        aux = new Comparable[a.length];
        sort(a,0,a.length-1);
    }
    private static void sort(Comparable[]a, int lo, int hi){
        // 将数组a[lo..hi]排序
        if(hi<=lo) return;
        int mid = lo + (hi - lo)/2;
        sort(a,lo,mid); //左半边排序
        sort(a,mid+1,hi); //右半边排序
        merge(a,lo,mid,hi);   //归并结果
        System.out.println("lo:"+lo+"mid:"+mid+"hi:"+hi);
    }
    public static void merge(Comparable[]a, int lo, int mid,int hi){
        //将a[lo..mid] 和a[mid+1..hi] 归并
        int i = lo, j= mid+1;

        // 将a[lo..hi]复制到aux[lo..hi] ，需要额外的一个存储空间
        for(int k = lo;k<= hi;k++){
            aux[k] = a[k];
        }

        // 开始归并到a[lo..hi]
        for(int k=lo;k<=hi;k++){
            if(i>mid){      // 左边到头了, 用右边的元素继续
                a[k] = aux[j++];
            }else if(j > hi){       // 右边到头了 ，用左边的元素继续
                a[k] = aux[i++];
            }else if(less(aux[j] ,aux[i])){   // 右边的元素比较小，用右边的
                a[k] = aux[j++];
            }else {
                a[k] = aux[i++];            // 不用做啥
            }
        }
    }

	// merge的输出， 各个分段排序，再各个分段不停的合并
	lo:0   mid:0   hi:1
	lo:0   mid:1   hi:2
	lo:3   mid:3   hi:4
	lo:0   mid:2   hi:4
	lo:5   mid:5   hi:6
	lo:7   mid:7   hi:8
	lo:5   mid:6   hi:8
	lo:0   mid:4   hi:8




# 快速排序

	核心在切分上面，选一个数，左边都是小于该数， 右边都是大于该数， 然后递归到左侧和右侧

	private static void sort(Comparable[] a,int lo, int hi){
        if(hi<=lo) return;
        int j = partition(a,lo,hi);   //切分
        sort(a,lo,j-1);     //将左半部分a[lo..j-1]排序
        sort(a,j+1,hi);     //将右半部分a[j+1..hi]排序
    }

    private static int partition(Comparable[]a, int lo, int hi){
        //将数组切分为a[lo..i-1], a[i], a[i+1..hi]
        int i = lo, j=hi+1;   //左右扫描指针
        Comparable v = a[lo];   // 切分元素
        while(true){
            //扫描左右， 检查扫描是否结束并交换元素
            while (less(a[++i],v)){
                if(i==hi)break;      //从左往右扫描，找到比切分元素大的就停止,a[i]就是大的元素
            }
            while (less(v,a[--j])){
                if(j==lo)break;      // 从右往左扫描， 找到比切分元素小的就停止,a[j]就是小的元素
            }
            if(i>=j){
                break;      // 大的a[i]本来就在右边了，不用管了
            }
            exch(a,i,j);        // 如果有，那么一直不停的交换 大的a[i]和 小的a[j]
        }
        exch(a,lo,j);   // 将切分元素和比较小的a[j]交换一下
        return j;       // a[lo..j-1] <= a[j] <= a[j+1..hi]达成
    }

	切分的记录
	lo:0        hi:10       j:1
	lo:2        hi:10       j:4
	lo:2        hi:3       j:3
	lo:5        hi:10       j:9
	lo:5        hi:8       j:5
	lo:6        hi:8       j:6
	lo:7        hi:8       j:7

# 优先队列

	可以插入，可以删除最大值

# 堆排序

	当一棵二叉树的每个结点都大于等于它的两个子结点时，称为堆有序
	有序堆可以表现成数组形式，0位置不要，1位置是根结点，k结点的父结点是k/2
	父结点p的左孩子是p*2， 右孩子是p*2+1

	private void swim(int k)		//上浮，跟父结点进行交换
	{
		while(k>1 && less( k/2,k))
		{
			exch(k/2,k);		// k/2是父结点
			k= k/2;
		}
	}
	

	堆排序步骤： 
	1.首先把无序的数组变成大顶堆，从中间开始遍历一半即可，不断的下沉
	2.然后循环到只剩2个元素，把最大的堆顶元素跟最小的末尾元素进行交换，然后把长度-1，这样最后的位置就是最大的元素了
	3.然后把最小的顶端元素继续下沉到它应该去的位置上，重新组成大顶堆，重复上面的步骤即可

	 public static void sort(int[] a){
        int N= a.length-1;                //要排序的长度
        for(int k=N/2;k>=1;k--){        // 首先要制造大顶堆
            sink(a,k,N);                // 遍历一半的数据，k是孩子节点
        }
        pl(a);
        while (N>1){
            exch(a,1,N--);      // 把最大的顶点a[1]跟最后的元素（最小的）进行交换， 这样最大的值就放在最后了，然后将最大值排除
            sink(a,1,N);        // 用排除了最大值的剩余部分再组成新的大顶堆，循环往复
        }
        pl(a);
    }

    private static void sink(int[]a,int k, int N)	//下沉成大顶堆
    {
        while(2*k <= N)     // k是父节点
        {
            int j = 2*k;                            // j为最后一个孩子节点
            if(j<N && less(a,j,j+1)){           // 如果右孩子大于左孩子，j变成右孩子
                j++;
            }
            if(less(a,j,k)){           //如果孩子节点a[j]小于父节点a[k], 那么就对了
                break;
            }
            exch(a,k,j);   // 如果孩子节点a[j]大于父节点a[k] ，那么交换位置，孩子节点上浮
            k = j;         // 父节点变更为孩子节点，开始向下继续沉
        }
    }



# 二叉查找树BST

	每个结点的值都大于左子树的值， 而小于右子树的值

	查找的时候，如果该加点不等于，那么判断是小于就递归左子节点， 如果大于该加点就递归右子节点

	二叉树查找树的最小值就是一直递归查找左子树， 直到找到左子树为空的就是最小值

	删除最小值的节点，递归查找到左子节点为null的节点，然后返回右子节点

	删除任意节点，指向被删除节点的链接保存为t；将x指向它的后续节点min（t.right）右链接中的最小值；	将x的右链接指向t.right；将x的左链接设为t.left,t的父节点指向x。


# 二叉树的遍历

	前序遍历：先根节点，左子树，右子树
	中序遍历：左子树，根节点，右子树
	后序遍历：左子树，右子树，根节点


# 2-3树

	有3个节点， 分别是左子节点小于a，中子节点在a-b之间，右子节点大于b


# 红黑二叉查找树

	红链接将2个节点链接成3节点， 黑链接是普通链接	
	红黑二叉树，即是二叉树， 也是2-3树
	通过旋转，很容易达到平衡二叉树


# 散列（hash）

	哈希函数：建立起数据元素的存放位置与数据元素的关键字之间的对应关系的函数。即使用哈希函数可将被查找的键转换为数组的索引。

	理想情况下它应该运算简单并且保证任何两个不同的关键字映射到不同的单元（索引值）。但是，这是不可能的，很多时候我们都需要处理多个键被哈希到同一个索引值的情况，即哈希碰撞冲突，解决冲突有链表的拉链法；线性探测等方法。

# 图

	图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。
	
	图的遍历， 深度优先和广度优先

	//深度优先
	private void dfs(Digraph graph, int index) {
        visited[index] = true;
        for(int i : graph.adj(index)) {
            if(!visited[i])
                dfs(graph,i);   
        }
    }

	//广度优先
	 private void bfs(AdjListDigraph graph, int index) {
        //在JSE中LinkedList实现了Queue接口
        Queue<Integer> queue = new LinkedList<>();
        visited[index] = true;
        queue.add(index);
        while(!queue.isEmpty()) {
            int vertex = queue.poll();
            for(int i : graph.adj(vertex)) {
                if(!visited[i]) {
                    visited[i] = true;
                    queue.offer(i);
                }
            }
        }
    }



	最小生成树， 图的生成树是它的一棵含有所有顶点的无环连通子图。一棵加权图的最小生成树（MST）是它的一棵权值（所有边的权值之和）最小的生成树。

	计算最小生成树的算法Prim，	Kruskal

	Prim每次将权值最小的横切边加入生成树中,从顶点0开始，首先将顶点0加入到树中（标记），顶点0和其它点的横切边（这里即为顶点0的邻接边）加入优先队列，将权值最小的横切边出队，加入生成树中。此时相当于也向树中添加了一个顶点2，接着将集合（顶点1，2组成）和另一个集合（除1,2的顶点组成）间的横切边加入到优先队列中，如此这般，直到队列为空。
	
	Kruskal算法的思想是按照边的权重顺序来生成最小生成树，首先将图中所有边加入优先队列，将权重最小的边出队加入最小生成树，保证加入的边不与已经加入的边形成环，直到树中有V-1到边为止。
	
	最短路径, Dijkstra算法,边的松弛
	


# 菲波那切数列

	f(0)=0
	f(1)=1
	f(n) = f(n-1)+f(n-2)	//n>=2

	递归方法计算量大，容易死机
	可以推导成通项公式，直接求值
	

# TopK

	n个数中找出最大的k个数
	1.全局排序， 缺点是没必要全部都排序
	2.局部排序， 可以用冒泡排序
	3.用前k个数生成小顶堆， 然后遍历后面的元素，如果有大于节点的就下沉
	4.跟快速排序类似，找到分治的点之后，判断一下是否满足k个，如果满足，就不用管其他部分了，也是局部排序

# 数1

	求正整数二进制有多少个1
	1. 循环uint32的32个位，每次右移
	2. n&(n-1)可以消除最后一个1，循环n>0即可
	3. 二次查表法，提前计算好，然后查表即可，可以多次查表，这样节省很多存储空间


# 